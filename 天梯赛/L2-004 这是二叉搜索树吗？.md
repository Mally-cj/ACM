

## **L2-004** **这是二叉搜索树吗？**



推荐 [博客1](https://blog.csdn.net/weixin_42949480/article/details/105435671)

#### 考查点：前序遍历

**前序遍历的特点**

 前序遍历结果的特点是第一个为根节点，然后是左子树和右子树。

二叉搜索树前序遍历的特点是第一个节点（根节点）比左子树大，比右子树小，那么定义两个变量tl、tr分别在待确定的前序数组从左到右遍历和从右向左，确定左儿子和右儿子区间，如果tr-tl=1，那么肯定对的，否则，就不是前序遍历。镜像的话大于左子树小于右子树换一下就行。



```c++
# include<bits/stdc++.h>
using namespace  std;
int data[1009],mirror=0,fau;
vector<int>ans;
void build(int a,int b)
{
    int root=data[a];
    if(a==b){ans.push_back(root);return;}
    ++a;
    int tl=a,tr=b;
    if(mirror==0)
    {
      while (tl<=b  && data[tl]<root)++tl;
      while (tr>=a  && data[tr]>=root)--tr;
    }
    else {
        while (tl<=b && data[tl]>=root)++tl;
        while (tr>=a && data[tr]<root)--tr;
    }
    tl--;tr++;
    if(tr-tl!=1){
        fau=1;
        return;
    }

    if(a<=tl)build(a,tl);
    if(tr<=b)build(tr,b);
    ans.push_back(root);
}
int main()
{
//    freopen("in.text","r",stdin);
    int n;
    cin>>n;
    for(int i=1;i<=n;++i)cin>>data[i];

    mirror=0;fau=0;
    build(1,n);
    if(fau==1)
    {
        ans.clear();
        mirror=1;
        fau=0;
        build(1,n);
    }

    if(fau)printf("NO\n");
    else{
        printf("YES\n");
        for(int i=0;i<ans.size();++i)printf("%d%s",ans[i],i==ans.size()-1?"":" ");
    }

    return 0;

}
```



## L2-005 集合相似度

#### 考查点：set容器的使用

[参考博客](https://blog.csdn.net/hy971216/article/details/80507310) 





## L2-006 **树的遍历** 



从后序遍历里找到根节点，再从中序遍历里找到左子数和右子树的内容和节点数目。

从而确认左子树的后序列遍历顺序。于是递归。

