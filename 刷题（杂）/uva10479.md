## UVA 10479 找规律



##### 题意

Hendrie序列是个自描述序列

H（1）=0，如果把H中的每个整数x变成x个0



分析

**找规律**

0 1 0 2 1 0 0 3 0 2 1 1 0 0 0 4 1 0 0 3 0 2 0 2 1 1 1 0 0 0 0 5 0 2 1 1 0 0 0 4 1 0 0 3 1 0 0 3 0 2 0 2 0 2 1 1 1 1 0 0 0 0 0 6

1. 第$2^k$ 位是k

2. 把序列在 $2^k$ 处分割，得到子串

   ```
   0 |1 |0 2 | 1 0 0 3| 0 2 1 1 0 0 0 4| 1 0 0 3 0 2 0 2 1 1 1 0 0 0 0 5| 0 2 1 1 0 0 0 4 1 0 0 3 1 0 0 3 0 2 0 2 0 2 1 1 1 1 0 0 0 0 0 6
   ```

   所以可以得到子串 .子串的长度len=1<<（编号-1） （编号=0时不成立）

   s[0]=0,

   s[1]=1

   s[2]=02

   s[3]=1003

   s[4]=02110004

   s[5]=1 0 0 3 0 2 0 2 1 1 1 0 0 0 0 5

3. 在第$2^{k}$ 往前到 第 $2^{k-1}$ 处，为 k-1个s[0], k-2个s[1],...1个s[k-2].

   比如第 $2^6=32$ 处， 0 2 1 1 0 0 0 4 1 0 0 3 1 0 0 3 0 2 0 2 0 2 1 1 1 1 0 0 0 0 0 6，就是5个"0",4个“1”，3个“02”，2个“1003”，1个“02110004”。

   







```C++
#include "bits/stdc++.h"
using namespace  std;
typedef long long ll ;
const int MAXN=1E6+10;
int dfs(ll n)
{
    printf("n=%d\n",n);
    int k=0;
    for(;;++k)if((1<<k)>=n)break;

    if((1<<k)==n )return k;

    //单独处理子串为0的情况
    ll cha=(1<<k)-n;
    if(cha<=(k-1) )dfs(1);
    cha-=k-1;

    int subs;  //子串编号
    for( subs=1;;++subs)
    {
        int num=1<<(subs-1);
        if(cha<=(num *(k-subs-1))){
            cha=cha%num;
            n= (1<<subs)-cha;
//            printf("num=%d cha=%d  n=%d  %d  %d\n",num,cha,n,1<<subs,1<<subs-cha);
            return dfs(n);
        }
        else cha-=num*(k-subs-1);
//        printf("num=%d  cha=%d\n",num,cha);
    }
}
int main()
{
    freopen("in.text","r",stdin);

    ll n;
  while (scanf("%lld",&n)&&n)
  {
        cout<<dfs(n)<<endl;
  }
  return 0;
}
```

