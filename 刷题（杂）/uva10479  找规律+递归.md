## UVA 10479 找规律+递归

记：想清楚了写，弄明白每个变量的含义，就会把很复杂的东西弄得一清二楚。

### 题意

Hendrie序列是个自描述序列

H（1）=0，如果把H中的每个整数x变成x个0



### 分析

#### 找规律

0 1 0 2 1 0 0 3 0 2 1 1 0 0 0 4 1 0 0 3 0 2 0 2 1 1 1 0 0 0 0 5 0 2 1 1 0 0 0 4 1 0 0 3 1 0 0 3 0 2 0 2 0 2 1 1 1 1 0 0 0 0 0 6

1. 第$2^k$ 位是k

2. 把序列在 $2^k$ 处分割，得到子串

   ```
   0 |1 |0 2 | 1 0 0 3| 0 2 1 1 0 0 0 4| 1 0 0 3 0 2 0 2 1 1 1 0 0 0 0 5| 0 2 1 1 0 0 0 4 1 0 0 3 1 0 0 3 0 2 0 2 0 2 1 1 1 1 0 0 0 0 0 6
   ```

   所以可以得到子串 .子串的长度len=1<<（编号-1） （编号=0时不成立）

   s[0]=0,

   s[1]=1

   s[2]=02

   s[3]=1003

   s[4]=02110004

   s[5]=1 0 0 3 0 2 0 2 1 1 1 0 0 0 0 5

3. 在第$2^{k}$ 往前到 第 $2^{k-1}$ 处，为 k-1个s[0], k-2个s[1],...1个s[k-2].

   比如第 $2^6=32$ 处， 0 2 1 1 0 0 0 4 1 0 0 3 1 0 0 3 0 2 0 2 0 2 1 1 1 1 0 0 0 0 0 6，就是5个"0",4个“1”，3个“02”，2个“1003”，1个“02110004”。

   

#### **代码实现遇到问题**

1. <<最大只能左移30位，就会溢出

2. 范围是0<n< $2^{63}$ ,因此只能用unsigned long long

#### **算法过程**

1. 给一个n，找到它属于的范围 $(2^{k-1},2^k)$

2. 如果$n=2^k$ ,那么就直接返回k，

3. 否则用$2^k-n+1$ 得到前缀的长度，再不断的减去（k-i-1）*s[i]的长度，直到找到存在哪个s[i]中。比如44，44存在于$2^5和2^6$ 之间，64-44=20，20-5\*1=15, 15- 4\*1=11, 11-3\*2= 5,  5<2*4,于是 5%4=1，可以知道答案存在于s[3]的倒数第1位中，

   （如果此处得到的是0，那么答案应该存在于s[i]的倒数第（s[i]的长度）位。

4. 再利用子串的分布情况，把求s[3]的第4位转化为求n，n=2^3 -1+1=8 ，再跳转到第2步。

### 代码

```c++
#include "bits/stdc++.h"
using namespace  std;
typedef  unsigned long long ll ;
ll data[100];  //2^k
ll dfs(ll n)
{
    ll k=0;
    for(;;++k)if(data[k]>=n)break;

    if( data[k]==n)return k;

    //单独处理子串为0的情况,编号为0的子串长度为0
    ll cha=data[k]-n;
    if(cha<=(k-1))return 0;
    cha-=k-1;

    int subs;
    //子串编号为subs的长度为data[subs-1], 处在（data[subs-1],data[subs]]这个位置上。
    for( subs=1;;++subs)
    {
        if( (k-subs-1) <1 )break;

        if( cha<=(data[subs-1]*(k-subs-1) )){
            cha=cha% data[subs-1];
            if(cha==0) cha=data[subs-1];  //如果是0，那么答案应该存在于该子串的倒数第data[subs-1] 位。
            n=data[subs]-cha+1;
            return dfs(n);
        }
            else cha-=data[subs-1]*(k-subs-1);
    }

}
int main()
{
//    freopen("in.text","r",stdin);

    data[0]=1;
    for(int k=1;k<=63;++k) data[k] = data[k - 1] * 2;
    

    ll n;
	while (cin>>n&&n)cout<<dfs(n)<<endl;
  
  return 0;
}
```





