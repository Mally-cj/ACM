## 树状数组

参考博客：[超赞博客](https://blog.csdn.net/bestsort/article/details/80796531#%E5%8D%95%E7%82%B9%E6%9B%B4%E6%96%B0%3A)

学习目标：掌握思想后把模板调出来，要带详细注解

树状数组：用于查询任意两位之间的所有元素之和，

线性排列，数和图是非线性

#### 基本介绍

树状数组（Binary Indexed Tree (B.I.T)，Fenwick Tree），也被称为二叉索引树

**应用情形**：子区间的数值在动态变化，而多次查询区间和。

**时间复杂度**：查询和修改复杂度都为 $log_2n$



#### 相关基础知识

lowbit(k)为整数k的二进制表示种 最右边的”1“的权值，用程序求值为

```c
lowbit(k)=k&(-k);
```

**原因**：补码和原码必然相反,所以原码有0的部位补码全是1,补码再+1之后由于进位那么最末尾的1和原码最右边的1一定是同一个位置(当遇到第一个1的时候补码此位为0,由于前面会进一位,所以此位会变为1)

比如12是  1100，-12 按补码的写法（先取反后加一）是0100，那么1100&0100=100，求得12最右边的1权值是4。



#### 原理

树状数组的排列

![mark](http://mally.oss-cn-qingdao.aliyuncs.com/PicGo上传的图片/20200730/104325047.png)

按层排，每层表示最右边的1在第几位，最下面的那层1是在最右边，倒数第2层就是在右起的第2位。

因此要一层层往上找时，就是要使得当前层的那个最右边的1变成0，也就是 

```
i+=lowbit(i)
```

比如aa[x]由p变成k后，树状数组的调整过程（每层反馈上去）就为

```c
for(i=x;i<cnt;i+=lowbit(i))c[i]+=k-aa[x];
aa[x]=k;
```

而求a[1]...a[i]的和，即求$s[x]=\sum_{k=1}^{x}a[k]$ ,就是上述的逆过程，要一直往下加。

```c++
s[x]=0;
for(int i=x;i>0;i-=lowbit(i))s[x]+=c[i];
```



### 进阶1：对非线性结构做动态统计

树状数组本来是用于一维线性数据的“动态统计”的，而如果数据本省是非线性结构的树结构，可以用 dfs序变成线性的，再树状数组对线性后的数据动态统计。

[POJ3321](https://vjudge.net/problem/POJ-3321) 体现了这一做法，dfs序列+树状数组



### 进阶2：求逆序对

> 如果 i > j && a[i] < a[j]， 则 a[i]和 a[j]就为一对逆序对。

[参考这个博客里的求逆序对](https://blog.csdn.net/bestsort/article/details/80796531#%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9)

每个数按有一个开始顺序0，从大到小排列后有一个顺序1。

往顺序1的表里按开始顺序一个个填1，计算要填的这个位置前面已经有多少个1，表示有多少个比它大的数已经先到达了。

![mark](http://mally.oss-cn-qingdao.aliyuncs.com/PicGo上传的图片/20200730/133613208.png)





