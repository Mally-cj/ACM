线段树用于区间修改，区间查询
其实是对二叉树的理解。
画一棵二叉树，左子树为2*n，右子树为2*n+1，如此就可以从一棵树的标号推知它孩子的编号，利于查询。

P3372 练习模板一
P

1.能实现查询区间和，和修改的，基础班，会tle，未加懒标记的写法。
代码0001
https://github.com/Mally-cj/csdn-/commit/2e713d4642167260c3f8d5a77a624802ca4adc32

懒标记lazytag的原理是如果要改变[x,y]区间的值，现在已经到了[a,b]（而a>=x&&b<=y）那么就不继续一个个去改变了，用到这个区间的数的时候再把改变值下放。

https://www.luogu.org/problemnew/solution/P3373
该博客讲太好！把遇到的问题讲清楚了，lazytag先执行乘法操作再去做加法。
遵循乘法优先的原则，

如果是乘法操作乘k，那就先把val乘上k，乘值乘上k，加值乘上k。

如果是加法操作加a，那就先把val加上a*边界范围大小，价值加上k。

下放操作，对左右孩子操作，
孩子的val=孩子的val*父亲的乘值+父亲的加值*孩子的范围大小
孩子的乘值=孩子的乘值 * 父亲的乘值
孩子的加值=孩子的加值*父亲的乘值 + 父亲的加值

如果是求和操作，先把lazytag下放，再算。

猴子题
把所有数据存起来，存到一个operation[maxn]数组里，
建立一个区间数，包含该
从后往前对operation操作，加载入区间树中，记当前书的序号为th，
如果这个节点的book==0，那么当前节点的exi[th]=1，就往下传
直到传到根节点，同时用lastbook[lef]=这本书的序号，have--；
返回去的时候要确定该节点的book值，还要确定exi值，增加exi。
如果have=0，就终止循环。

```
struct re
{
    map<int,int>exi;//这个区间内的猴子有没有最后读过这本书的
    exi.clear();
    int book=-1;
    //对于叶子节点，是这个猴子读的最后一本书的序列，对于根节点，是这个区间的猴子是否都确定了最后读的书，
    int fau=0;
};
```

从前往后，同样记当前书的序号为th,
如果这个节点的exi.count(th)并且fau=0,就可以往下，
当进去那个[x,y]后，就是这个节点的范围值都[在x,y]内的时候，
book值等于当前值，就把exi[th]++；如果exi