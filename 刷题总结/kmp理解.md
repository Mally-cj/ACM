# kmp

## 小记

看完王老师的课，再参考胡凡的算法笔记整理的，本文主要讲next数组，看懂了之后再去看  [图解kmp](https://www.cnblogs.com/zhangtianq/p/5839909.html) 就能懂kmp了。

***



什么是首尾最长串？

ababaab中，最长串就是ab。



### 什么是next数组？

记有s[0...k]为前缀，s[i-k...i]为后缀

next[i]表示使子串 s[0...i]的前缀s[0...k]等于后缀s[i-k...i]的最大的k，即长度为i的数组的首尾最长串的长度。



如何找一个数组的首尾最长串的长度，也就是求next[n].

显然可以暴力，但是时间是O(nm)，伤不起。



故而高效的做法是

1. one:初始化next数组，令j=next[0]=-1

2. 让i在1~len-1范围遍历，对每个i，执行 步骤3和4，以求解next[i]

3.  不断寻找 j-1长度内能满足s[j]=s[i]的首尾串，从长到短（即令j=next[j]）,直到发现根本不存在（j变为-1），或者找到了（s[i]=s[j+1]成立）。

4. 如果s[i]==s[j+1],则说明i长度内的首尾最长串是j+1（即next[i]=j+1）,否则说明i长度内不存在首尾串能满足要求（next[i]=-1）;

### 实践演练构建next数组

比如为ababaab寻找首尾最长串

:zero: 首先初始化next表和令j=-1

|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| i=0  | a | b | a   | b | a | a | b |
| j=-1  | -1   | -1   | -1  | -1 | -1 | -1 | -1 |



:one:  i=1

因为j=-1，说明前面i-1中不存在 首尾串，故只要重头配对即可。

s[1]和s[0]配对，故让b和a配

a	<font color="Hotpink">b</font>

  	a	b

s[1]!=s[0], 故next[i]=j=-1  ，此时next表如下

|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| i=1  | a    | b    | a    |      |      |      |      |
| j=-1 | -1   | -1   | 0    |      |      |      |      |

:two: i=2

因为j=-1，说明前面i-1中不存在 首尾串，故只要重头配对一次即可。

s[2]和s[0]配对，故让b和a配

a	b	<font color="Hotpink">a</font>

 	 	  a	b	b

s[1]==s[0], 故j=j+1=0,  next[2]=0  ，此时next表如下


|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| i=2  | a    | b    | a    |      |      |      |      |
| j=0  | -1   | -1   | 0    |      |      |      |      |



:three: i=3

s[3]和s[0+1]配对，故让b和b配

| a    | b | a | <font color="Hotpink">b</font> |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |  | a  | b | a | b |      |      |

s[3]==s[1], 故j=1, next[3]=1  ，此时next表如下


|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| i=3  | a    | b    | a    | b    |      |      |      |
| j=1  | -1   | -1   | 0    | 1    |      |      |      |

:four:i=4

因为这时j=1，说明i=3-1里的最长首尾串长度是2（从0开始的）

s[4]和s[1+1]配对

| a    | b | a | b | <font color="Hotpink">a</font> |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |  | a  | b | a | b | b |      |



s[1]==s[0], 故j=j+1=2,  next[4]=2  ，此时next表如下,

|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| i=4  | a    | b    | a    | b    | a    |      |      |
| j=2  | -1   | -1   | 0    | 1    | 2    |      |      |



:five:

因为这时j=2，说明i=4-1里的最长首尾串长度是3（从0开始的）

s[4]和s[2+1]配对
| a    | b | a | b | a | <font color="Hotpink">a</font> |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |  | a  | b | a | b | b |      |

不成功，s[4]!=s[3],故去找 i=4-1里的次小首尾串，j=next[j]=next[2]=0

让s[5]和s[o+1]配对

| a    | b | a | b | a | <font color="Hotpink">a</font> |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |  |   |  | a | b | a | b | a | a |

不成功 ，j=next[0]=-1

| a    | b    | a    | b    | a    | <font color="Hotpink">a</font> |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ------------------------------ | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      | a                              | b    | a    | b    | a    | a    |



成功，这时 j=-1+1=0,next[5]=0

:six: i=6

a	b	a	b	a	a	<font color="Hotpink">b</font>

​								a	b	a	b	a	a

匹配成功，j=0+1=1, next[6]=1.





