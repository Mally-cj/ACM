## 声明

首先，我需要声明，本文是在转载的基础上稍微修饰的，经过原创作者 [ZLH_HHHH（佐理慧学姐）](http://blog.csdn.net/zlh_hhhh/article/details/75604333) 的许可方才转载并修饰的，由于我就是初学者，并且是数学渣滓，所以我学姐建议我写一下残疾人手册，我当然是欣然接受！！！

## 正文：

文章写的有点急。有错误的地方望指出 
 我学习 FFT 是一个比较慢的过程。 期间反反复复。 我写这篇博文只是一个非常浅显的理解。同时也可以帮助初学者在学习FFT的时候。有所偏重。避免太多思维上的负担。

### 直接正题吧：

#### 首先：*D**F**T*

#### 本身并不负责多项式之间的乘法。

#### *D**F**T*

#### 只是一种变换。

#### *F**F**T*

#### 则是DFT的快速算法。（分治 提高效率）



 

<script id="MathJax-Element-4" type="math/tex; mode=display"></script>



#### 利用*F**F**T*

####  。我们快速的将多项式变换为利于计算的形式

#### 用这种方便计算的形式计算出来两个多项式的乘积。

#### 这时候我们虽然已经得到目标多项式。但其形式并不是我们想要的

#### 所以 之后利用 *F**F**T*

####  的 逆运算 又快速的变换回去



 

<script id="MathJax-Element-7" type="math/tex; mode=display"></script>



#### 我们记：*F**F**T*

#### 的逆运算为 *F**F**T*−

####  [1](https://blog.csdn.net/f_zyj/article/details/76037583#fn:1)



 

<script id="MathJax-Element-10" type="math/tex; mode=display"></script>



#### 对于一个*n*

#### 次多项A的表示。最常见的形式(系数表达)：

### *A*(*x*)=∑*i*=0*n*−1*a**i**x**i*

### 

####     这里的*n*次多项式是指最高次项指数为 *n*−1 的多项式

#### [2](https://blog.csdn.net/f_zyj/article/details/76037583#fn:2)

#### 小学生手算 系数形式 的 多项式乘法 的 复杂度是 *O*(*n*2)

#### 

#### 如果我们知道了一个*n*

#### 次多项式 的曲线上的*n*

#### 个不同的的点。

#### 我们是可以计算出来这个多项式的

#### *w**h**y*？

#### 

#### 把系数看做未知数。列出来n个方程组。解出来这n个系数。

#### 也就是说，给出曲线上的n个点：

####     <script id="MathJax-Element-18" type="math/tex;  mode=display"><(x_0,y_0),(x_1,y_1),(x_2,y_2),.....(x_{n-1},y_{n-1})></script>

#### 我们可以确定其系数形式；

#### 我们称这种表达一个多项式的方法叫：点值表达

#### 他有很多优点。比如可以*O*(*n*)

#### 时间内计算一个多项式乘法

#### 再给出一个多项式：

###     *B*(*x*)=∑*i*=0*n*−1*b**i**x**i*

### 

#### 设*A*(*x*)

#### 与*B*(*x*)

#### 在取相同x的点值表达为：

####     <script id="MathJax-Element-23" type="math/tex;  mode=display"><(x_0,A_0),(x_1,A_1),(x_2,A_2),.....(x_{2n-2},A_{2n-2})>\\  <(x_0,B_0),(x_1,B_1),(x_2,B_2),.....(x_{2n-2},B_{2n-2})></script>

#### 这里*A**i*=*A*(*x**i*)

####  ,   *B**i*=*B*(*x**i*)

#### 

#### 则*A*(*x*)∗*B*(*x*)

#### 为：

####     <script id="MathJax-Element-27" type="math/tex;  mode=display"><(x_0,A_0B_0),(x_1,A_1B_1),(x_2,A_2B_2),.....(x_{2n-2},A_{2n-2}B_{2n-2})></script>[3](https://blog.csdn.net/f_zyj/article/details/76037583#fn:3)

#### 非常方便。顺其自然；

#### 之所以*A*(*x*)

#### 与*B*(*x*)

#### 多取一些点。是因为*A*(*x*)∗*B*(*x*)

#### 的次数界增加。

#### 取点不足会导次数界达不到2*n*−1

#### 

#### 对于一个*n*

#### 次多项式。随机求其n个不同的点的朴素方法复杂度是*O*(*n*2)

#### 



 

<script id="MathJax-Element-34" type="math/tex; mode=display"></script>



#### 假设 n为偶数。那么我们把*A*(*x*)

#### 。重组为两个多项式：

#### 设其系数的下标为偶数组成的多项式为*A*[0](*x*)

#### ：

####     *A*[0](*x*)=*a*0+*a*2*x*+*a*4*x*2+...+*a**n*−2*x**n*2+1

#### 

#### 设其系数的下标为奇数组成的多项式为*A*[1](*x*)

#### ：

####     *A*[1](*x*)=*a*1+*a*3*x*+*a*5*x*2+...+*a**n*−1*x**n*2+1

#### 

#### 所以有：

####     *A*(*x**i*)=*A*[0](*x*2*i*)+*x**i**A*[1](*x*2*i*)

#### [4](https://blog.csdn.net/f_zyj/article/details/76037583#fn:4)

#### 好像并不会优化运算。

#### 因为    <script id="MathJax-Element-41" type="math/tex; mode=display">   </script> 

#### 依然有可能会组成n个不同的数字。

#### 那么我们要计算的规模不会减半。

#### 如果我们恰当选取一些x。是否会优化运算呢。

#### 例如：

####     <script id="MathJax-Element-42" type="math/tex; mode=display">   </script> 

#### 各个数字平方后。得到的集合大小减半：

###     <script id="MathJax-Element-43" type="math/tex; mode=display">   </script> 

#### 因为(−*x*)2=*x*2

#### 

#### 那么    *A*(−*x*)=*A*[0](*x*2)−*x**A*[1](*x*2)*A*(*x*)=*A*[0](*x*2)+*x**A*[1](*x*2)

#### 

#### 但是这种关系不会传递下去。平方后得到的数字全是不小于0的数字。

#### 再次递归又回到了原来的形式。很尴尬。

#### 不过这启迪我们。取相反数。然后平放。可以把问题规模减半。但再一次递归就失效了。是否存在不失效的取值呢。

####     <script id="MathJax-Element-46" type="math/tex; mode=display"></script>

### 如果对于一个有偶数个元素的数字集合。每个元素平方后。得到的新集合。去除重复元素后。集合大小能够减半。并且得到的新集合如果为偶数。新集合依然满足上面的性质。我们称这个集合有  折半 的性质。



 

<script id="MathJax-Element-47" type="math/tex; mode=display"></script>



### 如果我们可以快速的找到一个满足折半性质的自变量*x*

### 的取值集合.

### 分治就是可行的。

#### 有一种东西。可以满足我们的需求。

#### 那就是 —— n次单位复数根：

#### （使用复数确实让人有顾虑。这也是我学习FFT时最大 思想负担）





#### 我们定义*i*=−1−−−√

#### 

#### 那么形如    *c**o**s**θ*+*i*∗*s**i**n**θ*

#### 

#### 的复数有诸多良好的性质。

#### 例如：    (*c**o**s**θ*+*i*∗*s**i**n**θ*)*k*=*c**o**s* *k**θ*+*i*∗*s**i**n* *k**θ*

#### 

#### 上面的性质可以用数学归纳法得到（较为简单。这里不做证明

#### 我们记：

###     *W**n*=*c**o**s*2*π**n*+*i*∗*s**i**n*2*π**n*

### 

#### 我会告诉你 多项式在x取下面的值时。有助于我们进行DFT

####     <script id="MathJax-Element-54" type="math/tex; mode=display">   </script> 

#### 上面的n个复数称为。n次单位复数根。（n次单位复数根是指这n个数）

#### 如果我们x取*W**k**n*

#### 时。根据刚才的分解：

####     *A*(*W**k**n*)=*A*[0]( (*W**k**n*)2)+*W**k**n**A*[1]((*W**k**n*)2)

#### 

### 而    (*W**k**n*)2=*W*2*k**n*=*c**o**s* 2*k*∗2*π**n*+*i*∗*s**i**n*2*k*∗2*π**n*=*c**o**s* 2*π**k**n*2+*i*∗*s**i**n*2*π**k**n*2=*W**k**n*2

### 

#### 因为三角函数的周期性：

#### 我们有：

###     *W**k**n*=*c**o**s**k*∗2*π**n*+*i*∗*s**i**n**k*∗2*π**n*=*c**o**s*(*k* *m**o**d* *n*)∗2*π**n*+*i*∗*s**i**n*(*k* *m**o**d* *n*)∗2*π**n*=*W**k* *m**o**d* *n**n*

### 

### 所以：    (*W**k**n*)2=*W**k**n*2=*W**k* *m**o**d* *n*2*n*2

### 

### 则：    <script id="MathJax-Element-60" type="math/tex; mode=display"><(W_n^0)^2,(W_n^1)^2,...(W_n^{n-1})^2>\\等效于\\   </script> 

#### 惊不惊喜，意不意外。

#### *x*

#### 的取值集合取单位复数根。不但满足折半的性质。而且还有一定的规律性。与原集合保持一致。

#### 这意味着我们只需要计算取：

### <*W*0*n*2,*W*1*n*2,...*W**n*2−1*n*2>

### 

#### 的*A*[0],*A*[1]

#### 

#### 问题范围减半。并且如果n为偶数。再次平方依然集合大小减半。

#### 记：    *A*[0]*k*=*A*[0](*W**k**n*2)=*A*[0]((*W**k**n*)2)*A*[1]*k*=*A*[1](*W**k**n*2)=*A*[1]((*W**k**n*)2)

#### 

#### 那么，当我们得到：

###     <script id="MathJax-Element-65" type="math/tex; mode=display">   </script>

#### 这意味着我们得到了所有的*A*[0]((*W**i**n*)2),*A*[1]((*W**i**n*)2)

####

#### 则：

####     *A*( *W**k**n*)=*A*[0]*k* *m**o**d**n*2+*W**k**n**A*[1]*k* *m**o**d* *n*2

#### 

#### 即得到了：    <script id="MathJax-Element-68" type="math/tex; mode=display">   </script> 

#### 其中*A**k*=*A*(*W**k**n*)

#### 

#### 当然。FFT的计算 n要取2的整数次幂 。这是因为每次减半。我们可以把不足的系数用0填充。

#### 上面过程可以看作 ，取单位复数根计算目标y向量，如下图：

####     ⎡⎣⎢⎢⎢⎢⎢(*W*0*n*)0(*W*1*n*)0⋮(*W**n*−1*n*)0(*W*0*n*)1(*W*1*n*)1⋮(*W**n*−1*n*)1⋯⋯⋱⋯(*W*0*n*)*n*−1(*W*1*n*)*n*−1⋮(*W**n*−1*n*)*n*−1⎤⎦⎥⎥⎥⎥⎥⎡⎣⎢⎢⎢⎢*a*0*a*1⋮*a**n*−1⎤⎦⎥⎥⎥⎥=⎡⎣⎢⎢⎢⎢*A*0*A*1⋮*A**n*−1⎤⎦⎥⎥⎥⎥

#### 

#### 本着尽可能简单的原则。我们不在特别的说这个矩阵。

#### 因为之前说关于系数的n个方程必然可解。所以上面的矩阵：

####     ⎡⎣⎢⎢⎢⎢⎢(*W*0*n*)0(*W*1*n*)0⋮(*W**n*−1*n*)0(*W*0*n*)1(*W*1*n*)1⋮(*W**n*−1*n*)1⋯⋯⋱⋯(*W*0*n*)*n*−1(*W*1*n*)*n*−1⋮(*W**n*−1*n*)*n*−1⎤⎦⎥⎥⎥⎥⎥

#### 

#### 必然存在逆矩阵[5](https://blog.csdn.net/f_zyj/article/details/76037583#fn:5)。（有线性代数基础的，或许不陌生）

#### 可能你还是有点迷惑。没关系：

#### 如果我们把FFT看作计算上面特别的矩阵相乘的算法呢。

#### 利用FFT我们可以快速得到：